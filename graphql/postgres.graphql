type Absence implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  occurredAt: Datetime!
  createdAt: Datetime!
  updatedAt: Datetime!
  studentId: Int

  # Reads a single `Student` that is related to this `Absence`.
  studentByStudentId: Student
}

# A condition to be used against `Absence` object types. All fields are tested for equality and combined with a logical ‘and.’
input AbsenceCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `occurredAt` field.
  occurredAt: Datetime

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `studentId` field.
  studentId: Int
}

# A connection to a list of `Absence` values.
type AbsencesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Absence` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Absence` and cursor to aid in pagination.
  edges: [AbsencesEdge]

  # A list of `Absence` objects.
  nodes: [Absence!]
}

# A `Absence` edge in the connection.
type AbsencesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Absence` at the end of the edge.
  node: Absence!
}

# Methods to use when ordering `Absence`.
enum AbsencesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  OCCURRED_AT_ASC
  OCCURRED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
}

# A connection to a list of `ArInternalMetadatum` values.
type ArInternalMetadataConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ArInternalMetadatum` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ArInternalMetadatum` and cursor to aid in pagination.
  edges: [ArInternalMetadataEdge]

  # A list of `ArInternalMetadatum` objects.
  nodes: [ArInternalMetadatum!]
}

# A `ArInternalMetadatum` edge in the connection.
type ArInternalMetadataEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ArInternalMetadatum` at the end of the edge.
  node: ArInternalMetadatum!
}

# Methods to use when ordering `ArInternalMetadatum`.
enum ArInternalMetadataOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  KEY_ASC
  KEY_DESC
  VALUE_ASC
  VALUE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type ArInternalMetadatum implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  key: String!
  value: String
  createdAt: Datetime!
  updatedAt: Datetime!
}

# A condition to be used against `ArInternalMetadatum` object types. All fields
# are tested for equality and combined with a logical ‘and.’
input ArInternalMetadatumCondition {
  # Checks for equality with the object’s `key` field.
  key: String

  # Checks for equality with the object’s `value` field.
  value: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

type Assessment implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String
  family: String
  subject: String
  createdAt: Datetime
  updatedAt: Datetime
}

# A condition to be used against `Assessment` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input AssessmentCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `family` field.
  family: String

  # Checks for equality with the object’s `subject` field.
  subject: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `Assessment` values.
type AssessmentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Assessment` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Assessment` and cursor to aid in pagination.
  edges: [AssessmentsEdge]

  # A list of `Assessment` objects.
  nodes: [Assessment!]
}

# A `Assessment` edge in the connection.
type AssessmentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Assessment` at the end of the edge.
  node: Assessment!
}

# Methods to use when ordering `Assessment`.
enum AssessmentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  FAMILY_ASC
  FAMILY_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A signed eight-byte integer. The upper big integer values are greater then the
# max value for a JavaScript number. Therefore all big integers will be output as
# strings and not numbers.
scalar BigInt

type Course implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  courseNumber: String
  courseDescription: String
  createdAt: Datetime
  updatedAt: Datetime
  schoolId: Int
}

# A condition to be used against `Course` object types. All fields are tested for equality and combined with a logical ‘and.’
input CourseCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `courseNumber` field.
  courseNumber: String

  # Checks for equality with the object’s `courseDescription` field.
  courseDescription: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `schoolId` field.
  schoolId: Int
}

# A connection to a list of `Course` values.
type CoursesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Course` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Course` and cursor to aid in pagination.
  edges: [CoursesEdge]

  # A list of `Course` objects.
  nodes: [Course!]
}

# A `Course` edge in the connection.
type CoursesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Course` at the end of the edge.
  node: Course!
}

# Methods to use when ordering `Course`.
enum CoursesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  COURSE_NUMBER_ASC
  COURSE_NUMBER_DESC
  COURSE_DESCRIPTION_ASC
  COURSE_DESCRIPTION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  SCHOOL_ID_ASC
  SCHOOL_ID_DESC
}

# A location in a connection that can be used for resuming pagination.
scalar Cursor

# The day, does not include a time.
scalar Date

# A point in time as described by the [ISO
# 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
scalar Datetime

type DelayedJob implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  priority: Int!
  attempts: Int!
  handler: String!
  lastError: String
  runAt: Datetime
  lockedAt: Datetime
  failedAt: Datetime
  lockedBy: String
  queue: String
  createdAt: Datetime
  updatedAt: Datetime
}

# A condition to be used against `DelayedJob` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input DelayedJobCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `priority` field.
  priority: Int

  # Checks for equality with the object’s `attempts` field.
  attempts: Int

  # Checks for equality with the object’s `handler` field.
  handler: String

  # Checks for equality with the object’s `lastError` field.
  lastError: String

  # Checks for equality with the object’s `runAt` field.
  runAt: Datetime

  # Checks for equality with the object’s `lockedAt` field.
  lockedAt: Datetime

  # Checks for equality with the object’s `failedAt` field.
  failedAt: Datetime

  # Checks for equality with the object’s `lockedBy` field.
  lockedBy: String

  # Checks for equality with the object’s `queue` field.
  queue: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `DelayedJob` values.
type DelayedJobsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `DelayedJob` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `DelayedJob` and cursor to aid in pagination.
  edges: [DelayedJobsEdge]

  # A list of `DelayedJob` objects.
  nodes: [DelayedJob!]
}

# A `DelayedJob` edge in the connection.
type DelayedJobsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `DelayedJob` at the end of the edge.
  node: DelayedJob!
}

# Methods to use when ordering `DelayedJob`.
enum DelayedJobsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  ATTEMPTS_ASC
  ATTEMPTS_DESC
  HANDLER_ASC
  HANDLER_DESC
  LAST_ERROR_ASC
  LAST_ERROR_DESC
  RUN_AT_ASC
  RUN_AT_DESC
  LOCKED_AT_ASC
  LOCKED_AT_DESC
  FAILED_AT_ASC
  FAILED_AT_DESC
  LOCKED_BY_ASC
  LOCKED_BY_DESC
  QUEUE_ASC
  QUEUE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type DisciplineIncident implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  incidentCode: String
  createdAt: Datetime!
  updatedAt: Datetime!
  incidentLocation: String
  incidentDescription: String
  occurredAt: Datetime!
  hasExactTime: Boolean
  studentId: Int

  # Reads a single `Student` that is related to this `DisciplineIncident`.
  studentByStudentId: Student
}

# A condition to be used against `DisciplineIncident` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input DisciplineIncidentCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `incidentCode` field.
  incidentCode: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `incidentLocation` field.
  incidentLocation: String

  # Checks for equality with the object’s `incidentDescription` field.
  incidentDescription: String

  # Checks for equality with the object’s `occurredAt` field.
  occurredAt: Datetime

  # Checks for equality with the object’s `hasExactTime` field.
  hasExactTime: Boolean

  # Checks for equality with the object’s `studentId` field.
  studentId: Int
}

# A connection to a list of `DisciplineIncident` values.
type DisciplineIncidentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `DisciplineIncident` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `DisciplineIncident` and cursor to aid in pagination.
  edges: [DisciplineIncidentsEdge]

  # A list of `DisciplineIncident` objects.
  nodes: [DisciplineIncident!]
}

# A `DisciplineIncident` edge in the connection.
type DisciplineIncidentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `DisciplineIncident` at the end of the edge.
  node: DisciplineIncident!
}

# Methods to use when ordering `DisciplineIncident`.
enum DisciplineIncidentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  INCIDENT_CODE_ASC
  INCIDENT_CODE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  INCIDENT_LOCATION_ASC
  INCIDENT_LOCATION_DESC
  INCIDENT_DESCRIPTION_ASC
  INCIDENT_DESCRIPTION_DESC
  OCCURRED_AT_ASC
  OCCURRED_AT_DESC
  HAS_EXACT_TIME_ASC
  HAS_EXACT_TIME_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
}

type DiscontinuedService implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  serviceId: Int
  recordedByEducatorId: Int
  discontinuedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

# A condition to be used against `DiscontinuedService` object types. All fields
# are tested for equality and combined with a logical ‘and.’
input DiscontinuedServiceCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `serviceId` field.
  serviceId: Int

  # Checks for equality with the object’s `recordedByEducatorId` field.
  recordedByEducatorId: Int

  # Checks for equality with the object’s `discontinuedAt` field.
  discontinuedAt: Datetime

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `DiscontinuedService` values.
type DiscontinuedServicesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `DiscontinuedService` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `DiscontinuedService` and cursor to aid in pagination.
  edges: [DiscontinuedServicesEdge]

  # A list of `DiscontinuedService` objects.
  nodes: [DiscontinuedService!]
}

# A `DiscontinuedService` edge in the connection.
type DiscontinuedServicesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `DiscontinuedService` at the end of the edge.
  node: DiscontinuedService!
}

# Methods to use when ordering `DiscontinuedService`.
enum DiscontinuedServicesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SERVICE_ID_ASC
  SERVICE_ID_DESC
  RECORDED_BY_EDUCATOR_ID_ASC
  RECORDED_BY_EDUCATOR_ID_DESC
  DISCONTINUED_AT_ASC
  DISCONTINUED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type Educator implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  email: String!
  encryptedPassword: String!
  resetPasswordToken: String
  resetPasswordSentAt: Datetime
  rememberCreatedAt: Datetime
  signInCount: Int!
  currentSignInAt: Datetime
  lastSignInAt: Datetime
  currentSignInIp: String
  lastSignInIp: String
  createdAt: Datetime
  updatedAt: Datetime
  admin: Boolean
  phone: String
  fullName: String
  stateId: String
  localId: String
  staffType: String
  schoolId: Int
  schoolwideAccess: Boolean!
  gradeLevelAccess: [String]
  restrictedToSpedStudents: Boolean!
  restrictedToEnglishLanguageLearners: Boolean!
  canViewRestrictedNotes: Boolean!
  districtwideAccess: Boolean!
  canSetDistrictwideAccess: Boolean!
  studentSearchbarJson: String

  # Reads and enables pagination through a set of `EducatorSectionAssignment`.
  educatorSectionAssignmentsByEducatorId(
    # The method to use when ordering `EducatorSectionAssignment`.
    orderBy: EducatorSectionAssignmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EducatorSectionAssignmentCondition
  ): EducatorSectionAssignmentsConnection
}

# A condition to be used against `Educator` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input EducatorCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `email` field.
  email: String

  # Checks for equality with the object’s `encryptedPassword` field.
  encryptedPassword: String

  # Checks for equality with the object’s `resetPasswordToken` field.
  resetPasswordToken: String

  # Checks for equality with the object’s `resetPasswordSentAt` field.
  resetPasswordSentAt: Datetime

  # Checks for equality with the object’s `rememberCreatedAt` field.
  rememberCreatedAt: Datetime

  # Checks for equality with the object’s `signInCount` field.
  signInCount: Int

  # Checks for equality with the object’s `currentSignInAt` field.
  currentSignInAt: Datetime

  # Checks for equality with the object’s `lastSignInAt` field.
  lastSignInAt: Datetime

  # Checks for equality with the object’s `currentSignInIp` field.
  currentSignInIp: String

  # Checks for equality with the object’s `lastSignInIp` field.
  lastSignInIp: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `admin` field.
  admin: Boolean

  # Checks for equality with the object’s `phone` field.
  phone: String

  # Checks for equality with the object’s `fullName` field.
  fullName: String

  # Checks for equality with the object’s `stateId` field.
  stateId: String

  # Checks for equality with the object’s `localId` field.
  localId: String

  # Checks for equality with the object’s `staffType` field.
  staffType: String

  # Checks for equality with the object’s `schoolId` field.
  schoolId: Int

  # Checks for equality with the object’s `schoolwideAccess` field.
  schoolwideAccess: Boolean

  # Checks for equality with the object’s `gradeLevelAccess` field.
  gradeLevelAccess: [String]

  # Checks for equality with the object’s `restrictedToSpedStudents` field.
  restrictedToSpedStudents: Boolean

  # Checks for equality with the object’s `restrictedToEnglishLanguageLearners` field.
  restrictedToEnglishLanguageLearners: Boolean

  # Checks for equality with the object’s `canViewRestrictedNotes` field.
  canViewRestrictedNotes: Boolean

  # Checks for equality with the object’s `districtwideAccess` field.
  districtwideAccess: Boolean

  # Checks for equality with the object’s `canSetDistrictwideAccess` field.
  canSetDistrictwideAccess: Boolean

  # Checks for equality with the object’s `studentSearchbarJson` field.
  studentSearchbarJson: String
}

# A connection to a list of `Educator` values.
type EducatorsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Educator` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Educator` and cursor to aid in pagination.
  edges: [EducatorsEdge]

  # A list of `Educator` objects.
  nodes: [Educator!]
}

type EducatorSectionAssignment implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  sectionId: Int
  educatorId: Int
  id: BigInt!

  # Reads a single `Section` that is related to this `EducatorSectionAssignment`.
  sectionBySectionId: Section

  # Reads a single `Educator` that is related to this `EducatorSectionAssignment`.
  educatorByEducatorId: Educator
}

# A condition to be used against `EducatorSectionAssignment` object types. All
# fields are tested for equality and combined with a logical ‘and.’
input EducatorSectionAssignmentCondition {
  # Checks for equality with the object’s `sectionId` field.
  sectionId: Int

  # Checks for equality with the object’s `educatorId` field.
  educatorId: Int

  # Checks for equality with the object’s `id` field.
  id: BigInt
}

# A connection to a list of `EducatorSectionAssignment` values.
type EducatorSectionAssignmentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `EducatorSectionAssignment` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `EducatorSectionAssignment` and cursor to aid in pagination.
  edges: [EducatorSectionAssignmentsEdge]

  # A list of `EducatorSectionAssignment` objects.
  nodes: [EducatorSectionAssignment!]
}

# A `EducatorSectionAssignment` edge in the connection.
type EducatorSectionAssignmentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `EducatorSectionAssignment` at the end of the edge.
  node: EducatorSectionAssignment!
}

# Methods to use when ordering `EducatorSectionAssignment`.
enum EducatorSectionAssignmentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  SECTION_ID_ASC
  SECTION_ID_DESC
  EDUCATOR_ID_ASC
  EDUCATOR_ID_DESC
  ID_ASC
  ID_DESC
}

# A `Educator` edge in the connection.
type EducatorsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Educator` at the end of the edge.
  node: Educator!
}

# Methods to use when ordering `Educator`.
enum EducatorsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  ENCRYPTED_PASSWORD_ASC
  ENCRYPTED_PASSWORD_DESC
  RESET_PASSWORD_TOKEN_ASC
  RESET_PASSWORD_TOKEN_DESC
  RESET_PASSWORD_SENT_AT_ASC
  RESET_PASSWORD_SENT_AT_DESC
  REMEMBER_CREATED_AT_ASC
  REMEMBER_CREATED_AT_DESC
  SIGN_IN_COUNT_ASC
  SIGN_IN_COUNT_DESC
  CURRENT_SIGN_IN_AT_ASC
  CURRENT_SIGN_IN_AT_DESC
  LAST_SIGN_IN_AT_ASC
  LAST_SIGN_IN_AT_DESC
  CURRENT_SIGN_IN_IP_ASC
  CURRENT_SIGN_IN_IP_DESC
  LAST_SIGN_IN_IP_ASC
  LAST_SIGN_IN_IP_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ADMIN_ASC
  ADMIN_DESC
  PHONE_ASC
  PHONE_DESC
  FULL_NAME_ASC
  FULL_NAME_DESC
  STATE_ID_ASC
  STATE_ID_DESC
  LOCAL_ID_ASC
  LOCAL_ID_DESC
  STAFF_TYPE_ASC
  STAFF_TYPE_DESC
  SCHOOL_ID_ASC
  SCHOOL_ID_DESC
  SCHOOLWIDE_ACCESS_ASC
  SCHOOLWIDE_ACCESS_DESC
  GRADE_LEVEL_ACCESS_ASC
  GRADE_LEVEL_ACCESS_DESC
  RESTRICTED_TO_SPED_STUDENTS_ASC
  RESTRICTED_TO_SPED_STUDENTS_DESC
  RESTRICTED_TO_ENGLISH_LANGUAGE_LEARNERS_ASC
  RESTRICTED_TO_ENGLISH_LANGUAGE_LEARNERS_DESC
  CAN_VIEW_RESTRICTED_NOTES_ASC
  CAN_VIEW_RESTRICTED_NOTES_DESC
  DISTRICTWIDE_ACCESS_ASC
  DISTRICTWIDE_ACCESS_DESC
  CAN_SET_DISTRICTWIDE_ACCESS_ASC
  CAN_SET_DISTRICTWIDE_ACCESS_DESC
  STUDENT_SEARCHBAR_JSON_ASC
  STUDENT_SEARCHBAR_JSON_DESC
}

type EventNote implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  studentId: Int
  educatorId: Int
  eventNoteTypeId: Int
  text: String
  recordedAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  isRestricted: Boolean
}

type EventNoteAttachment implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  url: String!
  eventNoteId: Int!
  createdAt: Datetime!
  updatedAt: Datetime!
}

# A condition to be used against `EventNoteAttachment` object types. All fields
# are tested for equality and combined with a logical ‘and.’
input EventNoteAttachmentCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `url` field.
  url: String

  # Checks for equality with the object’s `eventNoteId` field.
  eventNoteId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `EventNoteAttachment` values.
type EventNoteAttachmentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `EventNoteAttachment` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `EventNoteAttachment` and cursor to aid in pagination.
  edges: [EventNoteAttachmentsEdge]

  # A list of `EventNoteAttachment` objects.
  nodes: [EventNoteAttachment!]
}

# A `EventNoteAttachment` edge in the connection.
type EventNoteAttachmentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `EventNoteAttachment` at the end of the edge.
  node: EventNoteAttachment!
}

# Methods to use when ordering `EventNoteAttachment`.
enum EventNoteAttachmentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  URL_ASC
  URL_DESC
  EVENT_NOTE_ID_ASC
  EVENT_NOTE_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A condition to be used against `EventNote` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input EventNoteCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `educatorId` field.
  educatorId: Int

  # Checks for equality with the object’s `eventNoteTypeId` field.
  eventNoteTypeId: Int

  # Checks for equality with the object’s `text` field.
  text: String

  # Checks for equality with the object’s `recordedAt` field.
  recordedAt: Datetime

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `isRestricted` field.
  isRestricted: Boolean
}

type EventNoteRevision implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  studentId: Int
  educatorId: Int
  eventNoteTypeId: Int
  text: String
  createdAt: Datetime
  updatedAt: Datetime
  eventNoteId: Int
  version: Int
}

# A condition to be used against `EventNoteRevision` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input EventNoteRevisionCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `educatorId` field.
  educatorId: Int

  # Checks for equality with the object’s `eventNoteTypeId` field.
  eventNoteTypeId: Int

  # Checks for equality with the object’s `text` field.
  text: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `eventNoteId` field.
  eventNoteId: Int

  # Checks for equality with the object’s `version` field.
  version: Int
}

# A connection to a list of `EventNoteRevision` values.
type EventNoteRevisionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `EventNoteRevision` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `EventNoteRevision` and cursor to aid in pagination.
  edges: [EventNoteRevisionsEdge]

  # A list of `EventNoteRevision` objects.
  nodes: [EventNoteRevision!]
}

# A `EventNoteRevision` edge in the connection.
type EventNoteRevisionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `EventNoteRevision` at the end of the edge.
  node: EventNoteRevision!
}

# Methods to use when ordering `EventNoteRevision`.
enum EventNoteRevisionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  EDUCATOR_ID_ASC
  EDUCATOR_ID_DESC
  EVENT_NOTE_TYPE_ID_ASC
  EVENT_NOTE_TYPE_ID_DESC
  TEXT_ASC
  TEXT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  EVENT_NOTE_ID_ASC
  EVENT_NOTE_ID_DESC
  VERSION_ASC
  VERSION_DESC
}

# A connection to a list of `EventNote` values.
type EventNotesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `EventNote` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `EventNote` and cursor to aid in pagination.
  edges: [EventNotesEdge]

  # A list of `EventNote` objects.
  nodes: [EventNote!]
}

# A `EventNote` edge in the connection.
type EventNotesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `EventNote` at the end of the edge.
  node: EventNote!
}

# Methods to use when ordering `EventNote`.
enum EventNotesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  EDUCATOR_ID_ASC
  EDUCATOR_ID_DESC
  EVENT_NOTE_TYPE_ID_ASC
  EVENT_NOTE_TYPE_ID_DESC
  TEXT_ASC
  TEXT_DESC
  RECORDED_AT_ASC
  RECORDED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_RESTRICTED_ASC
  IS_RESTRICTED_DESC
}

type EventNoteType implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String
  createdAt: Datetime
  updatedAt: Datetime
}

# A condition to be used against `EventNoteType` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input EventNoteTypeCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `EventNoteType` values.
type EventNoteTypesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `EventNoteType` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `EventNoteType` and cursor to aid in pagination.
  edges: [EventNoteTypesEdge]

  # A list of `EventNoteType` objects.
  nodes: [EventNoteType!]
}

# A `EventNoteType` edge in the connection.
type EventNoteTypesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `EventNoteType` at the end of the edge.
  node: EventNoteType!
}

# Methods to use when ordering `EventNoteType`.
enum EventNoteTypesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type FriendlyIdSlug implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  slug: String!
  sluggableId: Int!
  sluggableType: String
  scope: String
  createdAt: Datetime
}

# A condition to be used against `FriendlyIdSlug` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input FriendlyIdSlugCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `slug` field.
  slug: String

  # Checks for equality with the object’s `sluggableId` field.
  sluggableId: Int

  # Checks for equality with the object’s `sluggableType` field.
  sluggableType: String

  # Checks for equality with the object’s `scope` field.
  scope: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime
}

# A connection to a list of `FriendlyIdSlug` values.
type FriendlyIdSlugsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `FriendlyIdSlug` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `FriendlyIdSlug` and cursor to aid in pagination.
  edges: [FriendlyIdSlugsEdge]

  # A list of `FriendlyIdSlug` objects.
  nodes: [FriendlyIdSlug!]
}

# A `FriendlyIdSlug` edge in the connection.
type FriendlyIdSlugsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `FriendlyIdSlug` at the end of the edge.
  node: FriendlyIdSlug!
}

# Methods to use when ordering `FriendlyIdSlug`.
enum FriendlyIdSlugsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SLUG_ASC
  SLUG_DESC
  SLUGGABLE_ID_ASC
  SLUGGABLE_ID_DESC
  SLUGGABLE_TYPE_ASC
  SLUGGABLE_TYPE_DESC
  SCOPE_ASC
  SCOPE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
}

type Homeroom implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String
  createdAt: Datetime
  updatedAt: Datetime
  studentsCount: Int!
  educatorId: Int
  slug: String
  grade: String
  schoolId: Int
}

# A condition to be used against `Homeroom` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input HomeroomCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `studentsCount` field.
  studentsCount: Int

  # Checks for equality with the object’s `educatorId` field.
  educatorId: Int

  # Checks for equality with the object’s `slug` field.
  slug: String

  # Checks for equality with the object’s `grade` field.
  grade: String

  # Checks for equality with the object’s `schoolId` field.
  schoolId: Int
}

# A connection to a list of `Homeroom` values.
type HomeroomsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Homeroom` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Homeroom` and cursor to aid in pagination.
  edges: [HomeroomsEdge]

  # A list of `Homeroom` objects.
  nodes: [Homeroom!]
}

# A `Homeroom` edge in the connection.
type HomeroomsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Homeroom` at the end of the edge.
  node: Homeroom!
}

# Methods to use when ordering `Homeroom`.
enum HomeroomsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  STUDENTS_COUNT_ASC
  STUDENTS_COUNT_DESC
  EDUCATOR_ID_ASC
  EDUCATOR_ID_DESC
  SLUG_ASC
  SLUG_DESC
  GRADE_ASC
  GRADE_DESC
  SCHOOL_ID_ASC
  SCHOOL_ID_DESC
}

type IepDocument implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  fileName: String
  studentId: Int
  createdAt: Datetime!
  updatedAt: Datetime!
}

# A condition to be used against `IepDocument` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input IepDocumentCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `fileName` field.
  fileName: String

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `IepDocument` values.
type IepDocumentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `IepDocument` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `IepDocument` and cursor to aid in pagination.
  edges: [IepDocumentsEdge]

  # A list of `IepDocument` objects.
  nodes: [IepDocument!]
}

# A `IepDocument` edge in the connection.
type IepDocumentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `IepDocument` at the end of the edge.
  node: IepDocument!
}

# Methods to use when ordering `IepDocument`.
enum IepDocumentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  FILE_NAME_ASC
  FILE_NAME_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type ImportRecord implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  timeStarted: Datetime
  timeEnded: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!
  importerTimingJson: String
}

# A condition to be used against `ImportRecord` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ImportRecordCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `timeStarted` field.
  timeStarted: Datetime

  # Checks for equality with the object’s `timeEnded` field.
  timeEnded: Datetime

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `importerTimingJson` field.
  importerTimingJson: String
}

type ImportRecordDetail implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: BigInt!
  importRecordId: Int
  importer: String
  timeStarted: Datetime
  timeEnded: Datetime
  status: String
  errorMessage: String
  rowsProcessed: Int
  rowsExcluded: Int
  rowsCreated: Int
  rowsUpdated: Int
  rowsDeleted: Int
  rowsRejected: Int
  createdAt: Datetime!
  updatedAt: Datetime!
}

# A condition to be used against `ImportRecordDetail` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ImportRecordDetailCondition {
  # Checks for equality with the object’s `id` field.
  id: BigInt

  # Checks for equality with the object’s `importRecordId` field.
  importRecordId: Int

  # Checks for equality with the object’s `importer` field.
  importer: String

  # Checks for equality with the object’s `timeStarted` field.
  timeStarted: Datetime

  # Checks for equality with the object’s `timeEnded` field.
  timeEnded: Datetime

  # Checks for equality with the object’s `status` field.
  status: String

  # Checks for equality with the object’s `errorMessage` field.
  errorMessage: String

  # Checks for equality with the object’s `rowsProcessed` field.
  rowsProcessed: Int

  # Checks for equality with the object’s `rowsExcluded` field.
  rowsExcluded: Int

  # Checks for equality with the object’s `rowsCreated` field.
  rowsCreated: Int

  # Checks for equality with the object’s `rowsUpdated` field.
  rowsUpdated: Int

  # Checks for equality with the object’s `rowsDeleted` field.
  rowsDeleted: Int

  # Checks for equality with the object’s `rowsRejected` field.
  rowsRejected: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `ImportRecordDetail` values.
type ImportRecordDetailsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ImportRecordDetail` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ImportRecordDetail` and cursor to aid in pagination.
  edges: [ImportRecordDetailsEdge]

  # A list of `ImportRecordDetail` objects.
  nodes: [ImportRecordDetail!]
}

# A `ImportRecordDetail` edge in the connection.
type ImportRecordDetailsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ImportRecordDetail` at the end of the edge.
  node: ImportRecordDetail!
}

# Methods to use when ordering `ImportRecordDetail`.
enum ImportRecordDetailsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  IMPORT_RECORD_ID_ASC
  IMPORT_RECORD_ID_DESC
  IMPORTER_ASC
  IMPORTER_DESC
  TIME_STARTED_ASC
  TIME_STARTED_DESC
  TIME_ENDED_ASC
  TIME_ENDED_DESC
  STATUS_ASC
  STATUS_DESC
  ERROR_MESSAGE_ASC
  ERROR_MESSAGE_DESC
  ROWS_PROCESSED_ASC
  ROWS_PROCESSED_DESC
  ROWS_EXCLUDED_ASC
  ROWS_EXCLUDED_DESC
  ROWS_CREATED_ASC
  ROWS_CREATED_DESC
  ROWS_UPDATED_ASC
  ROWS_UPDATED_DESC
  ROWS_DELETED_ASC
  ROWS_DELETED_DESC
  ROWS_REJECTED_ASC
  ROWS_REJECTED_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# A connection to a list of `ImportRecord` values.
type ImportRecordsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ImportRecord` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ImportRecord` and cursor to aid in pagination.
  edges: [ImportRecordsEdge]

  # A list of `ImportRecord` objects.
  nodes: [ImportRecord!]
}

# A `ImportRecord` edge in the connection.
type ImportRecordsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ImportRecord` at the end of the edge.
  node: ImportRecord!
}

# Methods to use when ordering `ImportRecord`.
enum ImportRecordsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  TIME_STARTED_ASC
  TIME_STARTED_DESC
  TIME_ENDED_ASC
  TIME_ENDED_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IMPORTER_TIMING_JSON_ASC
  IMPORTER_TIMING_JSON_DESC
}

type Intervention implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  studentId: Int
  interventionTypeId: Int
  comment: String
  startDate: Date
  endDate: Date
  createdAt: Datetime
  updatedAt: Datetime
  educatorId: Int
  numberOfHours: Int
  goal: String
  customInterventionName: String
}

# A condition to be used against `Intervention` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input InterventionCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `interventionTypeId` field.
  interventionTypeId: Int

  # Checks for equality with the object’s `comment` field.
  comment: String

  # Checks for equality with the object’s `startDate` field.
  startDate: Date

  # Checks for equality with the object’s `endDate` field.
  endDate: Date

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `educatorId` field.
  educatorId: Int

  # Checks for equality with the object’s `numberOfHours` field.
  numberOfHours: Int

  # Checks for equality with the object’s `goal` field.
  goal: String

  # Checks for equality with the object’s `customInterventionName` field.
  customInterventionName: String
}

# A connection to a list of `Intervention` values.
type InterventionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Intervention` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Intervention` and cursor to aid in pagination.
  edges: [InterventionsEdge]

  # A list of `Intervention` objects.
  nodes: [Intervention!]
}

# A `Intervention` edge in the connection.
type InterventionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Intervention` at the end of the edge.
  node: Intervention!
}

# Methods to use when ordering `Intervention`.
enum InterventionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  INTERVENTION_TYPE_ID_ASC
  INTERVENTION_TYPE_ID_DESC
  COMMENT_ASC
  COMMENT_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  EDUCATOR_ID_ASC
  EDUCATOR_ID_DESC
  NUMBER_OF_HOURS_ASC
  NUMBER_OF_HOURS_DESC
  GOAL_ASC
  GOAL_DESC
  CUSTOM_INTERVENTION_NAME_ASC
  CUSTOM_INTERVENTION_NAME_DESC
}

type InterventionType implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String
  createdAt: Datetime
  updatedAt: Datetime
}

# A condition to be used against `InterventionType` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input InterventionTypeCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime
}

# A connection to a list of `InterventionType` values.
type InterventionTypesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `InterventionType` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `InterventionType` and cursor to aid in pagination.
  edges: [InterventionTypesEdge]

  # A list of `InterventionType` objects.
  nodes: [InterventionType!]
}

# A `InterventionType` edge in the connection.
type InterventionTypesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `InterventionType` at the end of the edge.
  node: InterventionType!
}

# Methods to use when ordering `InterventionType`.
enum InterventionTypesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

# An object with a globally unique `ID`.
interface Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: Cursor

  # When paginating forwards, the cursor to continue.
  endCursor: Cursor
}

type PrecomputedQueryDoc implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  key: String
  json: String
  createdAt: Datetime
  updatedAt: Datetime
  authorizedStudentsDigest: String
}

# A condition to be used against `PrecomputedQueryDoc` object types. All fields
# are tested for equality and combined with a logical ‘and.’
input PrecomputedQueryDocCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `key` field.
  key: String

  # Checks for equality with the object’s `json` field.
  json: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `authorizedStudentsDigest` field.
  authorizedStudentsDigest: String
}

# A connection to a list of `PrecomputedQueryDoc` values.
type PrecomputedQueryDocsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `PrecomputedQueryDoc` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `PrecomputedQueryDoc` and cursor to aid in pagination.
  edges: [PrecomputedQueryDocsEdge]

  # A list of `PrecomputedQueryDoc` objects.
  nodes: [PrecomputedQueryDoc!]
}

# A `PrecomputedQueryDoc` edge in the connection.
type PrecomputedQueryDocsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `PrecomputedQueryDoc` at the end of the edge.
  node: PrecomputedQueryDoc!
}

# Methods to use when ordering `PrecomputedQueryDoc`.
enum PrecomputedQueryDocsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  KEY_ASC
  KEY_DESC
  JSON_ASC
  JSON_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  AUTHORIZED_STUDENTS_DIGEST_ASC
  AUTHORIZED_STUDENTS_DIGEST_DESC
}

# The root query type which gives access points into the data universe.
type Query implements Node {
  # Fetches an object given its globally unique `ID`.
  node(
    # The globally unique `ID`.
    nodeId: ID!
  ): Node

  # Reads and enables pagination through a set of `Absence`.
  allAbsences(
    # The method to use when ordering `Absence`.
    orderBy: AbsencesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AbsenceCondition
  ): AbsencesConnection

  # Reads a single `Absence` using its globally unique `ID`.
  absence(
    # The globally unique `ID` to be used in selecting a single `Absence`.
    nodeId: ID!
  ): Absence
  absenceById(id: Int!): Absence

  # Reads and enables pagination through a set of `ArInternalMetadatum`.
  allArInternalMetadata(
    # The method to use when ordering `ArInternalMetadatum`.
    orderBy: ArInternalMetadataOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ArInternalMetadatumCondition
  ): ArInternalMetadataConnection

  # Reads a single `ArInternalMetadatum` using its globally unique `ID`.
  arInternalMetadatum(
    # The globally unique `ID` to be used in selecting a single `ArInternalMetadatum`.
    nodeId: ID!
  ): ArInternalMetadatum
  arInternalMetadatumByKey(key: String!): ArInternalMetadatum

  # Reads and enables pagination through a set of `Assessment`.
  allAssessments(
    # The method to use when ordering `Assessment`.
    orderBy: AssessmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AssessmentCondition
  ): AssessmentsConnection

  # Reads a single `Assessment` using its globally unique `ID`.
  assessment(
    # The globally unique `ID` to be used in selecting a single `Assessment`.
    nodeId: ID!
  ): Assessment
  assessmentById(id: Int!): Assessment

  # Reads and enables pagination through a set of `Course`.
  allCourses(
    # The method to use when ordering `Course`.
    orderBy: CoursesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: CourseCondition
  ): CoursesConnection

  # Reads a single `Course` using its globally unique `ID`.
  course(
    # The globally unique `ID` to be used in selecting a single `Course`.
    nodeId: ID!
  ): Course
  courseById(id: Int!): Course

  # Reads and enables pagination through a set of `DelayedJob`.
  allDelayedJobs(
    # The method to use when ordering `DelayedJob`.
    orderBy: DelayedJobsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: DelayedJobCondition
  ): DelayedJobsConnection

  # Reads a single `DelayedJob` using its globally unique `ID`.
  delayedJob(
    # The globally unique `ID` to be used in selecting a single `DelayedJob`.
    nodeId: ID!
  ): DelayedJob
  delayedJobById(id: Int!): DelayedJob

  # Reads and enables pagination through a set of `DisciplineIncident`.
  allDisciplineIncidents(
    # The method to use when ordering `DisciplineIncident`.
    orderBy: DisciplineIncidentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: DisciplineIncidentCondition
  ): DisciplineIncidentsConnection

  # Reads a single `DisciplineIncident` using its globally unique `ID`.
  disciplineIncident(
    # The globally unique `ID` to be used in selecting a single `DisciplineIncident`.
    nodeId: ID!
  ): DisciplineIncident
  disciplineIncidentById(id: Int!): DisciplineIncident

  # Reads and enables pagination through a set of `DiscontinuedService`.
  allDiscontinuedServices(
    # The method to use when ordering `DiscontinuedService`.
    orderBy: DiscontinuedServicesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: DiscontinuedServiceCondition
  ): DiscontinuedServicesConnection

  # Reads a single `DiscontinuedService` using its globally unique `ID`.
  discontinuedService(
    # The globally unique `ID` to be used in selecting a single `DiscontinuedService`.
    nodeId: ID!
  ): DiscontinuedService
  discontinuedServiceById(id: Int!): DiscontinuedService

  # Reads and enables pagination through a set of `EducatorSectionAssignment`.
  allEducatorSectionAssignments(
    # The method to use when ordering `EducatorSectionAssignment`.
    orderBy: EducatorSectionAssignmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EducatorSectionAssignmentCondition
  ): EducatorSectionAssignmentsConnection

  # Reads a single `EducatorSectionAssignment` using its globally unique `ID`.
  educatorSectionAssignment(
    # The globally unique `ID` to be used in selecting a single `EducatorSectionAssignment`.
    nodeId: ID!
  ): EducatorSectionAssignment
  educatorSectionAssignmentById(id: BigInt!): EducatorSectionAssignment

  # Reads and enables pagination through a set of `Educator`.
  allEducators(
    # The method to use when ordering `Educator`.
    orderBy: EducatorsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EducatorCondition
  ): EducatorsConnection

  # Reads a single `Educator` using its globally unique `ID`.
  educator(
    # The globally unique `ID` to be used in selecting a single `Educator`.
    nodeId: ID!
  ): Educator
  educatorById(id: Int!): Educator

  # Reads and enables pagination through a set of `EventNoteAttachment`.
  allEventNoteAttachments(
    # The method to use when ordering `EventNoteAttachment`.
    orderBy: EventNoteAttachmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EventNoteAttachmentCondition
  ): EventNoteAttachmentsConnection

  # Reads a single `EventNoteAttachment` using its globally unique `ID`.
  eventNoteAttachment(
    # The globally unique `ID` to be used in selecting a single `EventNoteAttachment`.
    nodeId: ID!
  ): EventNoteAttachment
  eventNoteAttachmentById(id: Int!): EventNoteAttachment

  # Reads and enables pagination through a set of `EventNoteRevision`.
  allEventNoteRevisions(
    # The method to use when ordering `EventNoteRevision`.
    orderBy: EventNoteRevisionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EventNoteRevisionCondition
  ): EventNoteRevisionsConnection

  # Reads a single `EventNoteRevision` using its globally unique `ID`.
  eventNoteRevision(
    # The globally unique `ID` to be used in selecting a single `EventNoteRevision`.
    nodeId: ID!
  ): EventNoteRevision
  eventNoteRevisionById(id: Int!): EventNoteRevision

  # Reads and enables pagination through a set of `EventNoteType`.
  allEventNoteTypes(
    # The method to use when ordering `EventNoteType`.
    orderBy: EventNoteTypesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EventNoteTypeCondition
  ): EventNoteTypesConnection

  # Reads a single `EventNoteType` using its globally unique `ID`.
  eventNoteType(
    # The globally unique `ID` to be used in selecting a single `EventNoteType`.
    nodeId: ID!
  ): EventNoteType
  eventNoteTypeById(id: Int!): EventNoteType

  # Reads and enables pagination through a set of `EventNote`.
  allEventNotes(
    # The method to use when ordering `EventNote`.
    orderBy: EventNotesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EventNoteCondition
  ): EventNotesConnection

  # Reads a single `EventNote` using its globally unique `ID`.
  eventNote(
    # The globally unique `ID` to be used in selecting a single `EventNote`.
    nodeId: ID!
  ): EventNote
  eventNoteById(id: Int!): EventNote

  # Reads and enables pagination through a set of `FriendlyIdSlug`.
  allFriendlyIdSlugs(
    # The method to use when ordering `FriendlyIdSlug`.
    orderBy: FriendlyIdSlugsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: FriendlyIdSlugCondition
  ): FriendlyIdSlugsConnection

  # Reads a single `FriendlyIdSlug` using its globally unique `ID`.
  friendlyIdSlug(
    # The globally unique `ID` to be used in selecting a single `FriendlyIdSlug`.
    nodeId: ID!
  ): FriendlyIdSlug
  friendlyIdSlugById(id: Int!): FriendlyIdSlug

  # Reads and enables pagination through a set of `Homeroom`.
  allHomerooms(
    # The method to use when ordering `Homeroom`.
    orderBy: HomeroomsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: HomeroomCondition
  ): HomeroomsConnection

  # Reads a single `Homeroom` using its globally unique `ID`.
  homeroom(
    # The globally unique `ID` to be used in selecting a single `Homeroom`.
    nodeId: ID!
  ): Homeroom
  homeroomById(id: Int!): Homeroom

  # Reads and enables pagination through a set of `IepDocument`.
  allIepDocuments(
    # The method to use when ordering `IepDocument`.
    orderBy: IepDocumentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: IepDocumentCondition
  ): IepDocumentsConnection

  # Reads a single `IepDocument` using its globally unique `ID`.
  iepDocument(
    # The globally unique `ID` to be used in selecting a single `IepDocument`.
    nodeId: ID!
  ): IepDocument
  iepDocumentById(id: Int!): IepDocument

  # Reads and enables pagination through a set of `ImportRecordDetail`.
  allImportRecordDetails(
    # The method to use when ordering `ImportRecordDetail`.
    orderBy: ImportRecordDetailsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ImportRecordDetailCondition
  ): ImportRecordDetailsConnection

  # Reads a single `ImportRecordDetail` using its globally unique `ID`.
  importRecordDetail(
    # The globally unique `ID` to be used in selecting a single `ImportRecordDetail`.
    nodeId: ID!
  ): ImportRecordDetail
  importRecordDetailById(id: BigInt!): ImportRecordDetail

  # Reads and enables pagination through a set of `ImportRecord`.
  allImportRecords(
    # The method to use when ordering `ImportRecord`.
    orderBy: ImportRecordsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ImportRecordCondition
  ): ImportRecordsConnection

  # Reads a single `ImportRecord` using its globally unique `ID`.
  importRecord(
    # The globally unique `ID` to be used in selecting a single `ImportRecord`.
    nodeId: ID!
  ): ImportRecord
  importRecordById(id: Int!): ImportRecord

  # Reads and enables pagination through a set of `InterventionType`.
  allInterventionTypes(
    # The method to use when ordering `InterventionType`.
    orderBy: InterventionTypesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: InterventionTypeCondition
  ): InterventionTypesConnection

  # Reads a single `InterventionType` using its globally unique `ID`.
  interventionType(
    # The globally unique `ID` to be used in selecting a single `InterventionType`.
    nodeId: ID!
  ): InterventionType
  interventionTypeById(id: Int!): InterventionType

  # Reads and enables pagination through a set of `Intervention`.
  allInterventions(
    # The method to use when ordering `Intervention`.
    orderBy: InterventionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: InterventionCondition
  ): InterventionsConnection

  # Reads a single `Intervention` using its globally unique `ID`.
  intervention(
    # The globally unique `ID` to be used in selecting a single `Intervention`.
    nodeId: ID!
  ): Intervention
  interventionById(id: Int!): Intervention

  # Reads and enables pagination through a set of `PrecomputedQueryDoc`.
  allPrecomputedQueryDocs(
    # The method to use when ordering `PrecomputedQueryDoc`.
    orderBy: PrecomputedQueryDocsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: PrecomputedQueryDocCondition
  ): PrecomputedQueryDocsConnection

  # Reads a single `PrecomputedQueryDoc` using its globally unique `ID`.
  precomputedQueryDoc(
    # The globally unique `ID` to be used in selecting a single `PrecomputedQueryDoc`.
    nodeId: ID!
  ): PrecomputedQueryDoc
  precomputedQueryDocById(id: Int!): PrecomputedQueryDoc

  # Reads and enables pagination through a set of `SchemaMigration`.
  allSchemaMigrations(
    # The method to use when ordering `SchemaMigration`.
    orderBy: SchemaMigrationsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SchemaMigrationCondition
  ): SchemaMigrationsConnection

  # Reads a single `SchemaMigration` using its globally unique `ID`.
  schemaMigration(
    # The globally unique `ID` to be used in selecting a single `SchemaMigration`.
    nodeId: ID!
  ): SchemaMigration
  schemaMigrationByVersion(version: String!): SchemaMigration

  # Reads and enables pagination through a set of `School`.
  allSchools(
    # The method to use when ordering `School`.
    orderBy: SchoolsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SchoolCondition
  ): SchoolsConnection

  # Reads a single `School` using its globally unique `ID`.
  school(
    # The globally unique `ID` to be used in selecting a single `School`.
    nodeId: ID!
  ): School
  schoolById(id: Int!): School

  # Reads and enables pagination through a set of `Section`.
  allSections(
    # The method to use when ordering `Section`.
    orderBy: SectionsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: SectionCondition
  ): SectionsConnection

  # Reads a single `Section` using its globally unique `ID`.
  section(
    # The globally unique `ID` to be used in selecting a single `Section`.
    nodeId: ID!
  ): Section
  sectionById(id: Int!): Section

  # Reads and enables pagination through a set of `ServiceType`.
  allServiceTypes(
    # The method to use when ordering `ServiceType`.
    orderBy: ServiceTypesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ServiceTypeCondition
  ): ServiceTypesConnection

  # Reads a single `ServiceType` using its globally unique `ID`.
  serviceType(
    # The globally unique `ID` to be used in selecting a single `ServiceType`.
    nodeId: ID!
  ): ServiceType
  serviceTypeById(id: Int!): ServiceType

  # Reads and enables pagination through a set of `ServiceUpload`.
  allServiceUploads(
    # The method to use when ordering `ServiceUpload`.
    orderBy: ServiceUploadsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ServiceUploadCondition
  ): ServiceUploadsConnection

  # Reads a single `ServiceUpload` using its globally unique `ID`.
  serviceUpload(
    # The globally unique `ID` to be used in selecting a single `ServiceUpload`.
    nodeId: ID!
  ): ServiceUpload
  serviceUploadById(id: Int!): ServiceUpload

  # Reads and enables pagination through a set of `Service`.
  allServices(
    # The method to use when ordering `Service`.
    orderBy: ServicesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: ServiceCondition
  ): ServicesConnection

  # Reads a single `Service` using its globally unique `ID`.
  service(
    # The globally unique `ID` to be used in selecting a single `Service`.
    nodeId: ID!
  ): Service
  serviceById(id: Int!): Service

  # Reads and enables pagination through a set of `StudentAssessment`.
  allStudentAssessments(
    # The method to use when ordering `StudentAssessment`.
    orderBy: StudentAssessmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StudentAssessmentCondition
  ): StudentAssessmentsConnection

  # Reads a single `StudentAssessment` using its globally unique `ID`.
  studentAssessment(
    # The globally unique `ID` to be used in selecting a single `StudentAssessment`.
    nodeId: ID!
  ): StudentAssessment
  studentAssessmentById(id: Int!): StudentAssessment

  # Reads and enables pagination through a set of `StudentRiskLevel`.
  allStudentRiskLevels(
    # The method to use when ordering `StudentRiskLevel`.
    orderBy: StudentRiskLevelsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StudentRiskLevelCondition
  ): StudentRiskLevelsConnection

  # Reads a single `StudentRiskLevel` using its globally unique `ID`.
  studentRiskLevel(
    # The globally unique `ID` to be used in selecting a single `StudentRiskLevel`.
    nodeId: ID!
  ): StudentRiskLevel
  studentRiskLevelById(id: Int!): StudentRiskLevel

  # Reads and enables pagination through a set of `StudentSectionAssignment`.
  allStudentSectionAssignments(
    # The method to use when ordering `StudentSectionAssignment`.
    orderBy: StudentSectionAssignmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StudentSectionAssignmentCondition
  ): StudentSectionAssignmentsConnection

  # Reads a single `StudentSectionAssignment` using its globally unique `ID`.
  studentSectionAssignment(
    # The globally unique `ID` to be used in selecting a single `StudentSectionAssignment`.
    nodeId: ID!
  ): StudentSectionAssignment
  studentSectionAssignmentById(id: BigInt!): StudentSectionAssignment

  # Reads and enables pagination through a set of `Student`.
  allStudents(
    # The method to use when ordering `Student`.
    orderBy: StudentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StudentCondition
  ): StudentsConnection

  # Reads a single `Student` using its globally unique `ID`.
  student(
    # The globally unique `ID` to be used in selecting a single `Student`.
    nodeId: ID!
  ): Student
  studentById(id: Int!): Student

  # Reads and enables pagination through a set of `Tardy`.
  allTardies(
    # The method to use when ordering `Tardy`.
    orderBy: TardiesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TardyCondition
  ): TardiesConnection

  # Reads a single `Tardy` using its globally unique `ID`.
  tardy(
    # The globally unique `ID` to be used in selecting a single `Tardy`.
    nodeId: ID!
  ): Tardy
  tardyById(id: Int!): Tardy

  # Exposes the root query type nested one level down. This is helpful for Relay 1
  # which can only query top level fields if they are in a particular form.
  query: Query!

  # The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  nodeId: ID!
}

type SchemaMigration implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  version: String!
}

# A condition to be used against `SchemaMigration` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input SchemaMigrationCondition {
  # Checks for equality with the object’s `version` field.
  version: String
}

# A connection to a list of `SchemaMigration` values.
type SchemaMigrationsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `SchemaMigration` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `SchemaMigration` and cursor to aid in pagination.
  edges: [SchemaMigrationsEdge]

  # A list of `SchemaMigration` objects.
  nodes: [SchemaMigration!]
}

# A `SchemaMigration` edge in the connection.
type SchemaMigrationsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `SchemaMigration` at the end of the edge.
  node: SchemaMigration!
}

# Methods to use when ordering `SchemaMigration`.
enum SchemaMigrationsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  VERSION_ASC
  VERSION_DESC
}

type School implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  stateId: Int
  schoolType: String
  name: String
  createdAt: Datetime
  updatedAt: Datetime
  localId: String
  slug: String
}

# A condition to be used against `School` object types. All fields are tested for equality and combined with a logical ‘and.’
input SchoolCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `stateId` field.
  stateId: Int

  # Checks for equality with the object’s `schoolType` field.
  schoolType: String

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `localId` field.
  localId: String

  # Checks for equality with the object’s `slug` field.
  slug: String
}

# A connection to a list of `School` values.
type SchoolsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `School` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `School` and cursor to aid in pagination.
  edges: [SchoolsEdge]

  # A list of `School` objects.
  nodes: [School!]
}

# A `School` edge in the connection.
type SchoolsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `School` at the end of the edge.
  node: School!
}

# Methods to use when ordering `School`.
enum SchoolsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STATE_ID_ASC
  STATE_ID_DESC
  SCHOOL_TYPE_ASC
  SCHOOL_TYPE_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  LOCAL_ID_ASC
  LOCAL_ID_DESC
  SLUG_ASC
  SLUG_DESC
}

type Section implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  sectionNumber: String
  termLocalId: String
  schedule: String
  roomNumber: String
  createdAt: Datetime
  updatedAt: Datetime
  courseId: Int

  # Reads and enables pagination through a set of `StudentSectionAssignment`.
  studentSectionAssignmentsBySectionId(
    # The method to use when ordering `StudentSectionAssignment`.
    orderBy: StudentSectionAssignmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StudentSectionAssignmentCondition
  ): StudentSectionAssignmentsConnection

  # Reads and enables pagination through a set of `EducatorSectionAssignment`.
  educatorSectionAssignmentsBySectionId(
    # The method to use when ordering `EducatorSectionAssignment`.
    orderBy: EducatorSectionAssignmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: EducatorSectionAssignmentCondition
  ): EducatorSectionAssignmentsConnection
}

# A condition to be used against `Section` object types. All fields are tested for equality and combined with a logical ‘and.’
input SectionCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `sectionNumber` field.
  sectionNumber: String

  # Checks for equality with the object’s `termLocalId` field.
  termLocalId: String

  # Checks for equality with the object’s `schedule` field.
  schedule: String

  # Checks for equality with the object’s `roomNumber` field.
  roomNumber: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `courseId` field.
  courseId: Int
}

# A connection to a list of `Section` values.
type SectionsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Section` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Section` and cursor to aid in pagination.
  edges: [SectionsEdge]

  # A list of `Section` objects.
  nodes: [Section!]
}

# A `Section` edge in the connection.
type SectionsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Section` at the end of the edge.
  node: Section!
}

# Methods to use when ordering `Section`.
enum SectionsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SECTION_NUMBER_ASC
  SECTION_NUMBER_DESC
  TERM_LOCAL_ID_ASC
  TERM_LOCAL_ID_DESC
  SCHEDULE_ASC
  SCHEDULE_DESC
  ROOM_NUMBER_ASC
  ROOM_NUMBER_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  COURSE_ID_ASC
  COURSE_ID_DESC
}

type Service implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  studentId: Int
  recordedByEducatorId: Int
  serviceTypeId: Int
  recordedAt: Datetime
  dateStarted: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  providedByEducatorName: String
  serviceUploadId: Int
  estimatedEndDate: Datetime
}

# A condition to be used against `Service` object types. All fields are tested for equality and combined with a logical ‘and.’
input ServiceCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `recordedByEducatorId` field.
  recordedByEducatorId: Int

  # Checks for equality with the object’s `serviceTypeId` field.
  serviceTypeId: Int

  # Checks for equality with the object’s `recordedAt` field.
  recordedAt: Datetime

  # Checks for equality with the object’s `dateStarted` field.
  dateStarted: Datetime

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `providedByEducatorName` field.
  providedByEducatorName: String

  # Checks for equality with the object’s `serviceUploadId` field.
  serviceUploadId: Int

  # Checks for equality with the object’s `estimatedEndDate` field.
  estimatedEndDate: Datetime
}

# A connection to a list of `Service` values.
type ServicesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Service` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Service` and cursor to aid in pagination.
  edges: [ServicesEdge]

  # A list of `Service` objects.
  nodes: [Service!]
}

# A `Service` edge in the connection.
type ServicesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Service` at the end of the edge.
  node: Service!
}

# Methods to use when ordering `Service`.
enum ServicesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  RECORDED_BY_EDUCATOR_ID_ASC
  RECORDED_BY_EDUCATOR_ID_DESC
  SERVICE_TYPE_ID_ASC
  SERVICE_TYPE_ID_DESC
  RECORDED_AT_ASC
  RECORDED_AT_DESC
  DATE_STARTED_ASC
  DATE_STARTED_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PROVIDED_BY_EDUCATOR_NAME_ASC
  PROVIDED_BY_EDUCATOR_NAME_DESC
  SERVICE_UPLOAD_ID_ASC
  SERVICE_UPLOAD_ID_DESC
  ESTIMATED_END_DATE_ASC
  ESTIMATED_END_DATE_DESC
}

type ServiceType implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  name: String
  createdAt: Datetime
  updatedAt: Datetime
  summerProgram: Boolean
}

# A condition to be used against `ServiceType` object types. All fields are tested
# for equality and combined with a logical ‘and.’
input ServiceTypeCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `name` field.
  name: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `summerProgram` field.
  summerProgram: Boolean
}

# A connection to a list of `ServiceType` values.
type ServiceTypesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ServiceType` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ServiceType` and cursor to aid in pagination.
  edges: [ServiceTypesEdge]

  # A list of `ServiceType` objects.
  nodes: [ServiceType!]
}

# A `ServiceType` edge in the connection.
type ServiceTypesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ServiceType` at the end of the edge.
  node: ServiceType!
}

# Methods to use when ordering `ServiceType`.
enum ServiceTypesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  SUMMER_PROGRAM_ASC
  SUMMER_PROGRAM_DESC
}

type ServiceUpload implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  uploadedByEducatorId: Int
  createdAt: Datetime!
  updatedAt: Datetime!
  fileName: String
}

# A condition to be used against `ServiceUpload` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input ServiceUploadCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `uploadedByEducatorId` field.
  uploadedByEducatorId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `fileName` field.
  fileName: String
}

# A connection to a list of `ServiceUpload` values.
type ServiceUploadsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `ServiceUpload` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `ServiceUpload` and cursor to aid in pagination.
  edges: [ServiceUploadsEdge]

  # A list of `ServiceUpload` objects.
  nodes: [ServiceUpload!]
}

# A `ServiceUpload` edge in the connection.
type ServiceUploadsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `ServiceUpload` at the end of the edge.
  node: ServiceUpload!
}

# Methods to use when ordering `ServiceUpload`.
enum ServiceUploadsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  UPLOADED_BY_EDUCATOR_ID_ASC
  UPLOADED_BY_EDUCATOR_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  FILE_NAME_ASC
  FILE_NAME_DESC
}

type Student implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  grade: String
  hispanicLatino: Boolean
  race: String
  freeReducedLunch: String
  createdAt: Datetime
  updatedAt: Datetime
  homeroomId: Int
  firstName: String
  lastName: String
  stateId: String
  homeLanguage: String
  schoolId: Int
  studentAddress: String
  registrationDate: Datetime
  localId: String
  programAssigned: String
  spedPlacement: String
  disability: String
  spedLevelOfNeed: String
  plan504: String
  limitedEnglishProficiency: String
  mostRecentMcasMathGrowth: Int
  mostRecentMcasElaGrowth: Int
  mostRecentMcasMathPerformance: String
  mostRecentMcasElaPerformance: String
  mostRecentMcasMathScaled: Int
  mostRecentMcasElaScaled: Int
  mostRecentStarReadingPercentile: Int
  mostRecentStarMathPercentile: Int
  enrollmentStatus: String
  dateOfBirth: Datetime
  riskLevel: Int
  gender: String
  primaryPhone: String
  primaryEmail: String
  house: String
  counselor: String

  # Reads and enables pagination through a set of `DisciplineIncident`.
  disciplineIncidentsByStudentId(
    # The method to use when ordering `DisciplineIncident`.
    orderBy: DisciplineIncidentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: DisciplineIncidentCondition
  ): DisciplineIncidentsConnection

  # Reads and enables pagination through a set of `Absence`.
  absencesByStudentId(
    # The method to use when ordering `Absence`.
    orderBy: AbsencesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: AbsenceCondition
  ): AbsencesConnection

  # Reads and enables pagination through a set of `Tardy`.
  tardiesByStudentId(
    # The method to use when ordering `Tardy`.
    orderBy: TardiesOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: TardyCondition
  ): TardiesConnection

  # Reads and enables pagination through a set of `StudentSectionAssignment`.
  studentSectionAssignmentsByStudentId(
    # The method to use when ordering `StudentSectionAssignment`.
    orderBy: StudentSectionAssignmentsOrderBy = PRIMARY_KEY_ASC

    # Read all values in the set before (above) this cursor.
    before: Cursor

    # Read all values in the set after (below) this cursor.
    after: Cursor

    # Only read the first `n` values of the set.
    first: Int

    # Only read the last `n` values of the set.
    last: Int

    # Skip the first `n` values from our `after` cursor, an alternative to cursor
    # based pagination. May not be used with `last`.
    offset: Int

    # A condition to be used in determining which values should be returned by the collection.
    condition: StudentSectionAssignmentCondition
  ): StudentSectionAssignmentsConnection
}

type StudentAssessment implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  scaleScore: Int
  growthPercentile: Int
  performanceLevel: String
  dateTaken: Datetime
  studentId: Int
  createdAt: Datetime
  updatedAt: Datetime
  percentileRank: Int
  instructionalReadingLevel: Float
  assessmentId: Int
  gradeEquivalent: String
}

# A condition to be used against `StudentAssessment` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StudentAssessmentCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `scaleScore` field.
  scaleScore: Int

  # Checks for equality with the object’s `growthPercentile` field.
  growthPercentile: Int

  # Checks for equality with the object’s `performanceLevel` field.
  performanceLevel: String

  # Checks for equality with the object’s `dateTaken` field.
  dateTaken: Datetime

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `percentileRank` field.
  percentileRank: Int

  # Checks for equality with the object’s `instructionalReadingLevel` field.
  instructionalReadingLevel: Float

  # Checks for equality with the object’s `assessmentId` field.
  assessmentId: Int

  # Checks for equality with the object’s `gradeEquivalent` field.
  gradeEquivalent: String
}

# A connection to a list of `StudentAssessment` values.
type StudentAssessmentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StudentAssessment` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StudentAssessment` and cursor to aid in pagination.
  edges: [StudentAssessmentsEdge]

  # A list of `StudentAssessment` objects.
  nodes: [StudentAssessment!]
}

# A `StudentAssessment` edge in the connection.
type StudentAssessmentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StudentAssessment` at the end of the edge.
  node: StudentAssessment!
}

# Methods to use when ordering `StudentAssessment`.
enum StudentAssessmentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  SCALE_SCORE_ASC
  SCALE_SCORE_DESC
  GROWTH_PERCENTILE_ASC
  GROWTH_PERCENTILE_DESC
  PERFORMANCE_LEVEL_ASC
  PERFORMANCE_LEVEL_DESC
  DATE_TAKEN_ASC
  DATE_TAKEN_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PERCENTILE_RANK_ASC
  PERCENTILE_RANK_DESC
  INSTRUCTIONAL_READING_LEVEL_ASC
  INSTRUCTIONAL_READING_LEVEL_DESC
  ASSESSMENT_ID_ASC
  ASSESSMENT_ID_DESC
  GRADE_EQUIVALENT_ASC
  GRADE_EQUIVALENT_DESC
}

# A condition to be used against `Student` object types. All fields are tested for equality and combined with a logical ‘and.’
input StudentCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `grade` field.
  grade: String

  # Checks for equality with the object’s `hispanicLatino` field.
  hispanicLatino: Boolean

  # Checks for equality with the object’s `race` field.
  race: String

  # Checks for equality with the object’s `freeReducedLunch` field.
  freeReducedLunch: String

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `homeroomId` field.
  homeroomId: Int

  # Checks for equality with the object’s `firstName` field.
  firstName: String

  # Checks for equality with the object’s `lastName` field.
  lastName: String

  # Checks for equality with the object’s `stateId` field.
  stateId: String

  # Checks for equality with the object’s `homeLanguage` field.
  homeLanguage: String

  # Checks for equality with the object’s `schoolId` field.
  schoolId: Int

  # Checks for equality with the object’s `studentAddress` field.
  studentAddress: String

  # Checks for equality with the object’s `registrationDate` field.
  registrationDate: Datetime

  # Checks for equality with the object’s `localId` field.
  localId: String

  # Checks for equality with the object’s `programAssigned` field.
  programAssigned: String

  # Checks for equality with the object’s `spedPlacement` field.
  spedPlacement: String

  # Checks for equality with the object’s `disability` field.
  disability: String

  # Checks for equality with the object’s `spedLevelOfNeed` field.
  spedLevelOfNeed: String

  # Checks for equality with the object’s `plan504` field.
  plan504: String

  # Checks for equality with the object’s `limitedEnglishProficiency` field.
  limitedEnglishProficiency: String

  # Checks for equality with the object’s `mostRecentMcasMathGrowth` field.
  mostRecentMcasMathGrowth: Int

  # Checks for equality with the object’s `mostRecentMcasElaGrowth` field.
  mostRecentMcasElaGrowth: Int

  # Checks for equality with the object’s `mostRecentMcasMathPerformance` field.
  mostRecentMcasMathPerformance: String

  # Checks for equality with the object’s `mostRecentMcasElaPerformance` field.
  mostRecentMcasElaPerformance: String

  # Checks for equality with the object’s `mostRecentMcasMathScaled` field.
  mostRecentMcasMathScaled: Int

  # Checks for equality with the object’s `mostRecentMcasElaScaled` field.
  mostRecentMcasElaScaled: Int

  # Checks for equality with the object’s `mostRecentStarReadingPercentile` field.
  mostRecentStarReadingPercentile: Int

  # Checks for equality with the object’s `mostRecentStarMathPercentile` field.
  mostRecentStarMathPercentile: Int

  # Checks for equality with the object’s `enrollmentStatus` field.
  enrollmentStatus: String

  # Checks for equality with the object’s `dateOfBirth` field.
  dateOfBirth: Datetime

  # Checks for equality with the object’s `riskLevel` field.
  riskLevel: Int

  # Checks for equality with the object’s `gender` field.
  gender: String

  # Checks for equality with the object’s `primaryPhone` field.
  primaryPhone: String

  # Checks for equality with the object’s `primaryEmail` field.
  primaryEmail: String

  # Checks for equality with the object’s `house` field.
  house: String

  # Checks for equality with the object’s `counselor` field.
  counselor: String
}

type StudentRiskLevel implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  studentId: Int
  level: Int
  createdAt: Datetime
  updatedAt: Datetime
  mcasMathRiskLevel: Int
  starMathRiskLevel: Int
  mcasElaRiskLevel: Int
  starReadingRiskLevel: Int
  limitedEnglishProficiencyRiskLevel: Int
}

# A condition to be used against `StudentRiskLevel` object types. All fields are
# tested for equality and combined with a logical ‘and.’
input StudentRiskLevelCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `level` field.
  level: Int

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `mcasMathRiskLevel` field.
  mcasMathRiskLevel: Int

  # Checks for equality with the object’s `starMathRiskLevel` field.
  starMathRiskLevel: Int

  # Checks for equality with the object’s `mcasElaRiskLevel` field.
  mcasElaRiskLevel: Int

  # Checks for equality with the object’s `starReadingRiskLevel` field.
  starReadingRiskLevel: Int

  # Checks for equality with the object’s `limitedEnglishProficiencyRiskLevel` field.
  limitedEnglishProficiencyRiskLevel: Int
}

# A connection to a list of `StudentRiskLevel` values.
type StudentRiskLevelsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StudentRiskLevel` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StudentRiskLevel` and cursor to aid in pagination.
  edges: [StudentRiskLevelsEdge]

  # A list of `StudentRiskLevel` objects.
  nodes: [StudentRiskLevel!]
}

# A `StudentRiskLevel` edge in the connection.
type StudentRiskLevelsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StudentRiskLevel` at the end of the edge.
  node: StudentRiskLevel!
}

# Methods to use when ordering `StudentRiskLevel`.
enum StudentRiskLevelsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  LEVEL_ASC
  LEVEL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  MCAS_MATH_RISK_LEVEL_ASC
  MCAS_MATH_RISK_LEVEL_DESC
  STAR_MATH_RISK_LEVEL_ASC
  STAR_MATH_RISK_LEVEL_DESC
  MCAS_ELA_RISK_LEVEL_ASC
  MCAS_ELA_RISK_LEVEL_DESC
  STAR_READING_RISK_LEVEL_ASC
  STAR_READING_RISK_LEVEL_DESC
  LIMITED_ENGLISH_PROFICIENCY_RISK_LEVEL_ASC
  LIMITED_ENGLISH_PROFICIENCY_RISK_LEVEL_DESC
}

# A connection to a list of `Student` values.
type StudentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Student` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Student` and cursor to aid in pagination.
  edges: [StudentsEdge]

  # A list of `Student` objects.
  nodes: [Student!]
}

type StudentSectionAssignment implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  sectionId: Int
  studentId: Int
  id: BigInt!
  gradeNumeric: Float
  gradeLetter: String

  # Reads a single `Section` that is related to this `StudentSectionAssignment`.
  sectionBySectionId: Section

  # Reads a single `Student` that is related to this `StudentSectionAssignment`.
  studentByStudentId: Student
}

# A condition to be used against `StudentSectionAssignment` object types. All
# fields are tested for equality and combined with a logical ‘and.’
input StudentSectionAssignmentCondition {
  # Checks for equality with the object’s `sectionId` field.
  sectionId: Int

  # Checks for equality with the object’s `studentId` field.
  studentId: Int

  # Checks for equality with the object’s `id` field.
  id: BigInt

  # Checks for equality with the object’s `gradeNumeric` field.
  gradeNumeric: Float

  # Checks for equality with the object’s `gradeLetter` field.
  gradeLetter: String
}

# A connection to a list of `StudentSectionAssignment` values.
type StudentSectionAssignmentsConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `StudentSectionAssignment` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `StudentSectionAssignment` and cursor to aid in pagination.
  edges: [StudentSectionAssignmentsEdge]

  # A list of `StudentSectionAssignment` objects.
  nodes: [StudentSectionAssignment!]
}

# A `StudentSectionAssignment` edge in the connection.
type StudentSectionAssignmentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `StudentSectionAssignment` at the end of the edge.
  node: StudentSectionAssignment!
}

# Methods to use when ordering `StudentSectionAssignment`.
enum StudentSectionAssignmentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  SECTION_ID_ASC
  SECTION_ID_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
  ID_ASC
  ID_DESC
  GRADE_NUMERIC_ASC
  GRADE_NUMERIC_DESC
  GRADE_LETTER_ASC
  GRADE_LETTER_DESC
}

# A `Student` edge in the connection.
type StudentsEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Student` at the end of the edge.
  node: Student!
}

# Methods to use when ordering `Student`.
enum StudentsOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  GRADE_ASC
  GRADE_DESC
  HISPANIC_LATINO_ASC
  HISPANIC_LATINO_DESC
  RACE_ASC
  RACE_DESC
  FREE_REDUCED_LUNCH_ASC
  FREE_REDUCED_LUNCH_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  HOMEROOM_ID_ASC
  HOMEROOM_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  STATE_ID_ASC
  STATE_ID_DESC
  HOME_LANGUAGE_ASC
  HOME_LANGUAGE_DESC
  SCHOOL_ID_ASC
  SCHOOL_ID_DESC
  STUDENT_ADDRESS_ASC
  STUDENT_ADDRESS_DESC
  REGISTRATION_DATE_ASC
  REGISTRATION_DATE_DESC
  LOCAL_ID_ASC
  LOCAL_ID_DESC
  PROGRAM_ASSIGNED_ASC
  PROGRAM_ASSIGNED_DESC
  SPED_PLACEMENT_ASC
  SPED_PLACEMENT_DESC
  DISABILITY_ASC
  DISABILITY_DESC
  SPED_LEVEL_OF_NEED_ASC
  SPED_LEVEL_OF_NEED_DESC
  PLAN_504_ASC
  PLAN_504_DESC
  LIMITED_ENGLISH_PROFICIENCY_ASC
  LIMITED_ENGLISH_PROFICIENCY_DESC
  MOST_RECENT_MCAS_MATH_GROWTH_ASC
  MOST_RECENT_MCAS_MATH_GROWTH_DESC
  MOST_RECENT_MCAS_ELA_GROWTH_ASC
  MOST_RECENT_MCAS_ELA_GROWTH_DESC
  MOST_RECENT_MCAS_MATH_PERFORMANCE_ASC
  MOST_RECENT_MCAS_MATH_PERFORMANCE_DESC
  MOST_RECENT_MCAS_ELA_PERFORMANCE_ASC
  MOST_RECENT_MCAS_ELA_PERFORMANCE_DESC
  MOST_RECENT_MCAS_MATH_SCALED_ASC
  MOST_RECENT_MCAS_MATH_SCALED_DESC
  MOST_RECENT_MCAS_ELA_SCALED_ASC
  MOST_RECENT_MCAS_ELA_SCALED_DESC
  MOST_RECENT_STAR_READING_PERCENTILE_ASC
  MOST_RECENT_STAR_READING_PERCENTILE_DESC
  MOST_RECENT_STAR_MATH_PERCENTILE_ASC
  MOST_RECENT_STAR_MATH_PERCENTILE_DESC
  ENROLLMENT_STATUS_ASC
  ENROLLMENT_STATUS_DESC
  DATE_OF_BIRTH_ASC
  DATE_OF_BIRTH_DESC
  RISK_LEVEL_ASC
  RISK_LEVEL_DESC
  GENDER_ASC
  GENDER_DESC
  PRIMARY_PHONE_ASC
  PRIMARY_PHONE_DESC
  PRIMARY_EMAIL_ASC
  PRIMARY_EMAIL_DESC
  HOUSE_ASC
  HOUSE_DESC
  COUNSELOR_ASC
  COUNSELOR_DESC
}

# A connection to a list of `Tardy` values.
type TardiesConnection {
  # Information to aid in pagination.
  pageInfo: PageInfo!

  # The count of *all* `Tardy` you could get from the connection.
  totalCount: Int

  # A list of edges which contains the `Tardy` and cursor to aid in pagination.
  edges: [TardiesEdge]

  # A list of `Tardy` objects.
  nodes: [Tardy!]
}

# A `Tardy` edge in the connection.
type TardiesEdge {
  # A cursor for use in pagination.
  cursor: Cursor

  # The `Tardy` at the end of the edge.
  node: Tardy!
}

# Methods to use when ordering `Tardy`.
enum TardiesOrderBy {
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  NATURAL
  ID_ASC
  ID_DESC
  OCCURRED_AT_ASC
  OCCURRED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  STUDENT_ID_ASC
  STUDENT_ID_DESC
}

type Tardy implements Node {
  # A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  nodeId: ID!
  id: Int!
  occurredAt: Datetime!
  createdAt: Datetime!
  updatedAt: Datetime!
  studentId: Int

  # Reads a single `Student` that is related to this `Tardy`.
  studentByStudentId: Student
}

# A condition to be used against `Tardy` object types. All fields are tested for equality and combined with a logical ‘and.’
input TardyCondition {
  # Checks for equality with the object’s `id` field.
  id: Int

  # Checks for equality with the object’s `occurredAt` field.
  occurredAt: Datetime

  # Checks for equality with the object’s `createdAt` field.
  createdAt: Datetime

  # Checks for equality with the object’s `updatedAt` field.
  updatedAt: Datetime

  # Checks for equality with the object’s `studentId` field.
  studentId: Int
}
